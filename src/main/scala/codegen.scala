package twiddle.dsl

import scala.lms.common._
import java.io.{PrintWriter,StringWriter,FileOutputStream}
import scala.reflect._
import scala.collection.BitSet
import scala.language.higherKinds
import scala.math.pow
import scala.language.implicitConversions

object CodeGen {
  import TwiddleAST._

  // TODO: Tagless interpreter for Twiddle AST
  // ? use LMS (eval.scala in LMS tutorial; Ops[T[_]])
  // either eval/pretty print code or generete C code

  def emitGenHeader() = println("// START OF CODE GENERATED BY TWIDDLE")
  def emitGenFooter() = println("// END OF CODE GENERATED BY TWIDDLE")

  // Multi-stage evaluator
  def eval(ast: AST[_]): Unit = {
    ast match {
      case Tup(hd: Term, Tup(tl1, tl2)) => eval_term(hd); eval(Tup(tl1, tl2))
      case Tup(hd: Term, Null()) => eval_term(hd)
      case Result(v, t) => eval(t)
      case _ => ()
    }
  }

  def eval_term(t: Term): Unit = t match {
    case Num(n) => print(n)
    case CStr(s) => print(s""""$s"""")
    case Bool(b) => if(b) print(1) else print(0)
    case Var(s) => print(s)
    case Decl(e) => e match {
      case F(v) => print("float "); eval_term(v); println(";")
      case I(v) => print("int "); eval_term(v); println(";")
      case D(v) => print("double "); eval_term(v); println(";")
      case S(v) => print("char* "); eval_term(v); println(";")
    }
    case Assign(v, e) => eval_term(v); print(" = "); eval_term(e); println(";")
    case Cast(c, v) => print("("); eval_term(c); print(")"); eval_term(v)
    case Const(e) => print("const "); eval_term(e)
    case IntPtr() => print("int* ")
    case Addr(e) => print("&("); eval_term(e); print(")")
    case Minus(a, b) => eval_term(a); print(" - "); eval_term(b)
    case Plus(a, b) => (a, b) match {
      // ! extract into `summarizeEffects()` function
      case (Result(v1, t1), Result(v2, t2)) => eval_term(t1); eval_term(t2); eval_term(v1); print(" + "); eval_term(v2)
      case (Result(v, t), exp) => eval_term(t); eval_term(exp); print(" + "); eval_term(v)
      case (exp, Result(v, t)) => eval_term(t); eval_term(exp); print(" + "); eval_term(v)
      case (e1, e2) => eval_term(e1); print(" + "); eval_term(e2)
    }
    case IfThenElse(cond, conseq, alt) => print("if("); eval_term(cond); print(") {"); eval_term(conseq); print("} else {"); eval_term(alt); println("}")
    case TernaryIf(cond, conseq, alt) => print("("); eval_term(cond); print(") ? "); eval_term(conseq); print(" : "); eval_term(alt)
    case Rshift(a, b) => print("("); eval_term(a); print(" >> "); eval_term(b); print(")")
    case Ref(e) => print("*("); eval_term(e); print(")")
    case Tup(hd: Term, tl: Term) => eval_term(hd); eval_term(tl)
    case Null() => ()
    case Gte(e1, e2) => eval_term(e1); print(" >= "); eval_term(e2)
    case Gt(e1, e2) => eval_term(e1); print(" > "); eval_term(e2)
    case Length(s: CStr) => print("strlen("); eval_term(s); print(")")
    case For(init, cond, variant, body) => print("for("); eval_term(init); print(";"); eval_term(cond); print(";"); eval_term(variant); println(")")
                                          println("{"); eval_term(body); println("}")
    case XOR(n1, n2) => eval_term(n1); print(" ^ "); eval_term(n2)
    case PreInc(v) => print("++("); eval_term(v); print(")")
    case otherwise => println(s"Unknown AST node $otherwise")
  }
}